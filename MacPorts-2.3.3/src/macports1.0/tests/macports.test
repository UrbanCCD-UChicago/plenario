# -*- coding: utf-8; mode: tcl; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- vim:fenc=utf-8:ft=tcl:et:sw=4:ts=4:sts=4

package require tcltest 2
namespace import tcltest::*
eval ::tcltest::configure $::argv

set pwd [file dirname [file normalize $argv0]]

source ../macports_test_autoconf.tcl
package require macports 1.0

# clean leftovers from interrupted tests
file delete -force $pwd/tmpdir

# use custom macports.conf and sources.conf
makeDirectory $pwd/tmpdir
makeDirectory $pwd/tmpdir/share
makeDirectory $pwd/tmpdir/var/macports/registry
set fd [open $pwd/tmpdir/macports.conf w+]
puts $fd "portdbpath $pwd/tmpdir/var/macports"
puts $fd "prefix $pwd/tmpdir"
puts $fd "variants_conf $pwd/tmpdir/variants.conf"
puts $fd "sources_conf $pwd/sources.conf"
puts $fd "applications_dir $pwd/tmpdir/Applications"
puts $fd "frameworks_dir $pwd/tmpdir/Library/Frameworks"
close $fd
set env(PORTSRC) $pwd/tmpdir/macports.conf
file link -symbolic $pwd/tmpdir/share/macports $macports::autoconf::prefix/share/macports
close [open $pwd/tmpdir/variants.conf w+]

# Debug options
array set ui_options {}
#set ui_options(ports_debug)   yes
#set ui_options(ports_verbose) yes
mportinit ui_options

package require portutil 1.0
package require portinstall 1.0
package require portuninstall 1.0
package require Thread
source ../../registry2.0/portuninstall.tcl
source ../../port1.0/port_autoconf.tcl
source ./library.tcl
macports_worker_init


test mportclose {
    Mport close unit test.
} -setup {
    set mport [mportopen file://.]
} -body {
    if {[catch {mportclose $mport}] != 0} {
       return "FAIL: cannot run mportclose"
    }
    if {[ditem_key $mport workername] != ""} {
       return "FAIL: port not closed"
    }
    return "Mport close successful."
} -cleanup {
    catch {mportclose $mport}
} -result "Mport close successful."


test mportinfo {
    Mport info uni test.
} -setup {
    set mport [mportopen file://.]
} -body {
    set res [mportinfo $mport]
    if {[lindex $res 2] != "canonical_active_variants"} {
        return "FAIL: cannot get ::PortInfo"
    }
    return "Mport info successful."
} -cleanup {
    mportclose $mport
} -result "Mport info successful."


test mportopen_installed {
    Mport installed unit test.
} -constraints {
    root
} -setup {
    set os.platform darwin
    set macosx_version 10.8
    set os.major 10
    set os_version 11
    set os_arch i386

    set supported_archs {}
    set configure.build_arch build_arch
    set portarchivetype tgz

    set destpath $pwd/work/destroot
    set portdbpath $pwd/portdbpath
    set workpath $pwd/fondu/work
    set portpath $pwd

    set subport fondu
    set version 3.0
    set revision 1
    set epoch i386

    file copy -force $pwd/Portfile /tmp/
    set mport [mportopen file://.]

    proc getportbuildpath {id {portname ""}} {
        global portdbpath
        regsub {://} $id {.} port_path
        regsub -all {/} $port_path {_} port_path
        return [file join $portdbpath build $port_path $portname]
    }

    proc getportworkpath_from_buildpath {portbuildpath} {
        return [file join $portbuildpath work]
    }

    proc getportworkpath_from_portdir {portpath {portname ""}} {
        return [getportworkpath_from_buildpath [getportbuildpath $portpath $portname]]
    }

    source $pwd/../../port1.0/portmain.tcl

    # sets up PortInfo array
    if {[eval_variants variations] != 0} {
        mportclose $mport
        error "Error evaluating variants"
    }

    # set $version var
    set workername [ditem_key $mport workername]

    # run destroot
    $workername eval eval_targets destroot

    # portinstall setup
    interp alias {} _cd {} cd
    set macosx_deployment_target $pwd/deploy_target
    file mkdir $pwd/$subport
    file link -symbolic $pwd/$subport/work $pwd/work

    if {[catch {portinstall::install_main}] != 0} {
        return "FAIL: cannot install port"
    }

    set variants {}
    set options {}

} -body {
    set res [mportopen_installed $subport $version $revision $variants $options]
    if {![string match "ditem_*" $res]} {
       return "FAIL: installed port not opened"
    }

    if {[catch {mportclose $res}] != 0} {
       return "FAIL: cannot close port"
    }
    if {[catch {mportclose $res}] != 1} {
       return "FAIL: installed port not closed"
    }
    return "Installed port open successful."

} -cleanup {
    if {[catch {portuninstall::uninstall_main}] != 0} {
        return "FAIL: cannot install port"
    }
    mportclose $mport

    file delete -force $pwd/work
    file delete -force $pwd/$subport
} -result "Installed port open successful."


test ui_isset {
    Ui is set unit test.
} -body {
    namespace eval macports {
    array set ui_options { test yes }
    }
    if {[macports::ui_isset test] != 1} {
       return "FAIL: set option not detected"
    }
    if {[macports::ui_isset port] != 0} {
       return "FAIL: unset option detected"
    }
    return "ui_isset successful."
} -result "ui_isset successful."


test global_option_isset {
    Global option is set unit test.
} -body {
    namespace eval macports {
    array set global_options { test yes }
    }
    if {[macports::global_option_isset test] != 1} {
       return "FAIL: set option not detected"
    }
    if {[macports::global_option_isset port] != 0} {
       return "FAIL: unset option detected"
    }
    return "Global option isset successful."
} -result "Global option isset successful."


test init_logging {
    Init logging unit test.
} -constraints {
    root
} -setup {
    set mport [mportopen file://.]
} -body {
    if {[macports::init_logging $mport] != 0} {
       return "FAIL: incorrect channels"
    }
    if {$macports::channels(any) != "stdout debuglog"} {
       return "FAIL: incorrect channels(any)"
    }
    if {$macports::channels(debug) != "debuglog"} {
       return "FAIL: incorrect channels(debug)"
    }
    return "Init logging successful."
} -cleanup {
    mportclose $mport
} -result "Init logging successful."


test ch_logging {
    Channel logging unit test. Assumes main.log filename.
} -constraints {
    root
} -setup {
    set mport [mportopen file://.]

    set portname [_mportkey $mport subport]
    set portpath [_mportkey $mport portpath]
    set logname [macports::getportlogpath $portpath $portname]
    file delete -force $logname

} -body {
    if {[macports::ch_logging $mport] != 0} {
       return "FAIL: channels not set"
    }
    if {![file exists $logname]} {
       return "FAIL: logname dir missing"
    }
    if {![file exists $logname/main.log]} {
       return "FAIL: main.log missing"
    }
    return "Channel logging successful."

} -cleanup {
    mportclose $mport
} -result "Channel logging successful."


test push_log {
    Push log unit test.
} -constraints {
    root
} -setup {
    set mport [mportopen file://.]
    set ::logenabled 1
} -body {
    if {[catch {macports::push_log $mport}] != 0} {
       return "FAIL: cannot push log"
    }
    if {[lindex $::logstack 0] != [list $::debuglog $::debuglogname]} {
       return "FAIL: incorrect logstack"
    }
    return "Push log successful."
} -cleanup {
    mportclose $mport
} -result "Push log successful."


test pop_log {
    Pop log unit test.
} -setup {
    set ::logenabled 1
    set ::logstack [open $pwd/logstack w+]
    set ::debuglog [open $pwd/log w+]
    set mport [mportopen file://.]
    if {[catch {macports::push_log $mport}] != 0} {
       return "FAIL: cannot push log"
    }
} -body {
    macports::pop_log
    if {$::debuglog != $::logstack} {
	return "FAIL: cannot pop log"
    }
    return "Pop log successful."
} -cleanup {
    unset ::logenabled
    unset ::logstack
    unset ::debuglog
    mportclose $mport
    file delete -force $pwd/log
    file delete -force $pwd/logstack
} -result "Pop log successful."


test set_phase {
    Set phase unit test.
} -body {
    set res [set_phase test]
    if {$macports::current_phase != "test"} {
	return "FAIL: phase not set"
    }
    return "Set phase successful."
} -result "Set phase successful."


test ui_message {
    UI message unit test.
} -setup {
    set fd [open $pwd/message w+]
    set fd2 [open $pwd/log w+]
    set macports::channels(0) $fd
    set macports::channels(debuglog) $fd2
    set macports::current_phase test
    set ::debuglog $fd2
} -body {
    set res [ui_message 0 prefix phase args]
    close $fd
    close $fd2
    set fd2 [open $pwd/message r]
    set line [read $fd2]
    if {$line != "prefixargs\n"} {
	return "FAIL: wrong message"
    }
    close $fd2

    set fd [open $pwd/message w+]
    set fd2 [open $pwd/log w+]
    set res [ui_message debuglog prefix phase -nonewline arg]
    close $fd
    close $fd2
    set fd2 [open $pwd/log r]
    set line [read $fd2]
    if {$line != "prefixarg"} {
	return "FAIL: wrong message"
    }
    close $fd2

    return "UI message successful."
} -cleanup {
    file delete -force $pwd/log
    file delete -force $pwd/message
} -result "UI message successful."


# test ui_init


test ui_prefix_default {
    UI prefix default unit test.
} -body {
    if {[macports::ui_prefix_default debug] ne {DEBUG: }} {
	return "FAIL: wrong prefix"
    }
    if {[macports::ui_prefix_default error] ne {Error: }} {
	return "FAIL: wrong prefix"
    }
    if {[macports::ui_prefix_default warn] ne {Warning: }} {
	return "FAIL: wrong prefix"
    }
    if {[macports::ui_prefix_default default] ne {}} {
	return "FAIL: wrong prefix"
    }
    return "UI prefix default successful."
} -result "UI prefix default successful."


test ui_channels_default {
    UI channels default unit test.
} -setup {
    set macports::ui_options(ports_debug) yes
    set macports::ui_options(ports_verbose) yes
    set macports::ui_options(ports_quiet) yes
} -body {
    if {[macports::ui_channels_default debug] ne {stderr}} {
	return "FAIL: stderr not set"
    }
    if {[macports::ui_channels_default info] ne {stdout}} {
	return "FAIL: stdout not set"
    }
    if {[macports::ui_channels_default notice] ne {}} {
	return "FAIL: channel not set"
    }
    if {[macports::ui_channels_default msg] ne {stdout}} {
	return "FAIL: channel not set"
    }
    if {[macports::ui_channels_default warn] ne {stderr}} {
	return "FAIL: channel not set"
    }
    if {[macports::ui_channels_default error] ne {stderr}} {
	return "FAIL: channel not set"
    }
    if {[macports::ui_channels_default default] ne {stdout}} {
	return "FAIL: channel not set"
    }
    return "UI channels default successful."
} -result "UI channels default successful."


test ui_warn_once {
    UI warn once unit test.
} -body {
    set res [ui_warn_once 0 test]
    if {$macports::warning_done(0) != 1} {
	return "FAIL: warning flag not set"
    }
    return "UI warn once successful."
} -result "UI warn once successful."


# Replace puts to catch errors 
# test puts


test findBinary {
    Find binary unit test.
} -body {
    if {[macports::findBinary pwd ls] != "/bin/pwd"} {
       return "FAIL: wrong binary"
    }
    if {[macports::findBinary pwd /bin/ls] != "/bin/ls"} {
       return "FAIL: wrong binary"
    }
    return "Find binary successful."
} -result "Find binary successful."


test binaryInPath {
    Binary in path unit test.
} -body {
    if {[catch {macports::binaryInPath zz}] != 1} {
       return "FAIL: invalid binary found"
    }
    if {[macports::binaryInPath ls] != "/bin/ls"} {
       return "FAIL: wrong binary found"
    }
    return "Binary in path successful."
} -result "Binary in path successful."


test getoption {
    Get option unit test.
} -body {
    set macports::test macports
    if {[macports::getoption test] != "macports"} {
	return "FAIL: cannot get option"
    }
    return "Get option successful."
} -result "Get option successful."


test setxcodeinfo {
    Set XCode info unit test.
} -constraints {
    root
} -setup {
    unset macports::xcodeversion
} -body {
    if {[macports::setxcodeinfo a b c] != ""} {
       return "FAIL: xcode binary not found"
    }
    if {![info exists macports::xcodeversion]} {
       return "FAIL: xcodeversion unset"
    }
    return "Set XCode version successful."
} -result "Set XCode version successful."


test set_developer_dir {
    Set developer dir unit test. Tests only for correct xcode-select dir.
} -constraints {
    root
} -body {
    unset macports::developer_dir

    if {[macports::set_developer_dir a b c] != ""} {
       return "FAIL: cannot set dev dir"
    }
    if {![info exists macports::developer_dir]} {
       return "FAIL: developer_dir var no set"
    }
    return "Set developer dir successful."
} -result "Set developer dir successful."


test _is_valid_developer_dir {
    Check valid dev dir unit test.
} -body {
    set macports::set_developer /Applications/Xcode.app/Contents/Developer
    if {[macports::_is_valid_developer_dir $macports::developer_dir] != 1} {
       return "FAIL: valid dir not detected"
    }
    return "Valid dev dir successful."
} -result "Valid dev dir successful."


# test mportinit


test mportshutdown {
    Mport shutdown unit test.
} -setup {
    unset macports::ping_cache

    set time [expr [clock seconds] - 86100]
    set time_exp [expr [clock seconds] - 87000]
    set macports::portdbpath $pwd/portdbpath
    set macports::ping_cache(host1) [list test $time]
    set macports::ping_cache(host2) [list test $time_exp]

    file mkdir $macports::portdbpath
    close [open $macports::portdbpath/pingtimes w+]

} -body {
    if {[mportshutdown] != ""} {
       return "FAIL: errors occured"
    }

    set res ""
    append res "host1 \{test " $time "\}"
    set fd [open $macports::portdbpath/pingtimes r]

    if {[gets $fd] != $res} {
       return "FAIL: wrong value saved"
    }
    close $fd
    return "Mportshutdown successful."

} -cleanup {
    file delete -force $macports::portdbpath
} -result "Mportshutdown successful."


test copy_xcode_plist {
    Copy xcode plist unit test.
} -constraints {
    root
} -body {
    set target $pwd/target

    if {[macports::copy_xcode_plist $target] != ""} {
       return "FAIL: cannot copy xcode plist"
    }
    if {![file exists $target/Library/Preferences/com.apple.dt.Xcode.plist]} {
       return "FAIL: missing plist file"
    }
    return "Copy xcode plist successful."
} -cleanup {
    file delete -force $target
} -result "Copy xcode plist successful."


test worker_init {
    Worker init unit test.
} -setup {
    set name [interp create]
    set portpath $pwd/portpath
    set porturl http://www.macports.org
    set portbuildpath $pwd/build
    set options {a b}
    set variations {1 2}
} -body {
    macports::worker_init $name $portpath $porturl $portbuildpath $options $variations
    if {$name != "interp0"} {
       return "FAIL: wrong workername"
    }
    if {[$name eval source Portfile] != "yes"} {
       return "FAIL: cannot load Portfile"
    }
    if {[$name eval findBinary ls] != "/bin/ls"} {
       return "FAIL: alias not created"
    }
    if {[$name eval return \$os_arch] != "i386"} {
       return "FAIL: var not set"
    }
    return "Worker init successful."
} -result "Worker init successful."


test create_thread {
    Create thread unit test.
} -body {
    unset macports::portinterp_options
    set macports::portinterp_options {a b}

    set res [macports::create_thread]
    if {![string match "tid0x*" $res]} {
       return "FAIL: cannot create thread"
    }
    return "Create thread successful."
} -result "Create thread successful."


test get_tar_flags {
    Get tar flags unit test.
} -body {
    if {[macports::get_tar_flags .tbz2] != "-j"} {
	return "FAIL: wrong flaga (-j)"
    }
    if {[macports::get_tar_flags .tgz] != "-z"} {
	return "FAIL: wrong flaga (-z)"
    }
    return "Get tar flags successful."
} -result "Get tar flags successful."


test fetch_port {
    Fetch port unit test.
} -body {
    set url http://packages.macports.org/fondu/fondu-060102_1.darwin_10.x86_64.tbz2
    set res [macports::fetch_port $url]
    if {$res != "${pwd}/portdbpath/portdirs/fondu-060102_1"} {
	return "FAIL: cannot fetch port"
    }
    return "Fetch port successful."
} -cleanup {
    file delete -force $pwd/portdbpath
} -result "Fetch port successful."


test getprotocol {
    Get protocol unit test.
} -body {
    if {[macports::getprotocol http://www.macports.org] != "http"} {
       return "FAIL: wrong protocol"
    }
    return "Get protocol successful."
} -result "Get protocol successful."


test getportdir {
    Get port directory unit test.
} -setup {
    close [open $pwd/local_file w+]
} -body {
    set url http://fondu.sourceforge.net/fondu_src-060102.tgz
    set res [macports::getportdir $url]
    if {$res != "${pwd}/portdbpath/portdirs/fondu_src-060102"} {
	return "FAIL: invalid port directory"
    }

    set url file://${pwd}/local_file
    if {[macports::getportdir $url] != "${pwd}/local_file"} {
	return "FAIL: invalid local port directory"
    }
    return "Get port dir successful."
} -cleanup {
    file delete -force $pwd/portdbpath
    file delete -force $pwd/local_file
} -result "Get port dir successful."


test getportresourcepath {
    Get port resource path. Doesn't check for 'file' protocol.
} -body {
    set macports::portdbpath $pwd/portdbpath
    set url "http://packages.macports.org/fondu/fondu-060102_1.darwin_12.x86_64.tbz2"
    set default_path $pwd/portdbpath/sources/rsync.macports.org/release/tarballs/ports/_resources
    set fallback_path $pwd/portdbpath/sources/packages.macports.org/fondu/fondu-060102_1.darwin_12.x86_64.tbz2/_resources

    if {[macports::getportresourcepath $url "" yes] != $default_path} {
       return "FAIL: wrong resource path"
    }
    if {[macports::getportresourcepath $url "" no] != $fallback_path} {
       return "FAIL: wrong fallback path"
    }
    if {[macports::getportresourcepath $url "test" no] != "${fallback_path}/test"} {
       return "FAIL: wrong fallback path with subdir"
    }

    return "Get resource path successful."
} -result "Get resource path successful."


test getdefaultportresourcepath {
    Get default port resource path unit test.
} -body {
    set path test/path
    set macports::sources_default file://$pwd
    if {[macports::getdefaultportresourcepath $path] != "${pwd}/_resources/${path}"} {
       return "FAIL: wrong file res path"
    }

    set macports::sources_default http://$pwd
    set default_source_url [lindex ${macports::sources_default} 0]
    set right_path [macports::getsourcepath $default_source_url]/_resources/test/path
    if {[macports::getdefaultportresourcepath $path] != $right_path} {
       return "FAIL: wrong http res path"
    }
    return "Default res path successful."
} -result "Default res path successful."


# test mportopen


test mporttraverse {
    Mport traverse unit test. Uses 3rd column of the Portfile.
} -setup {
    file mkdir $pwd/porttree
    file mkdir $pwd/porttree/cat1/fondu
    file mkdir $pwd/porttree/cat2/fondu

    file copy -force $pwd/Portfile $pwd/porttree/cat1/fondu/Portfile
    file copy -force $pwd/Portfile $pwd/porttree/cat2/fondu/Portfile

    proc test_proc {file} {
       global pwd res
       set fd [open ${pwd}/porttree/${file}/Portfile r]
       gets $fd line
       append res [lindex [split $line " "] 3]
    }

    global res
    set res ""
} -body {
    mporttraverse test_proc $pwd/porttree
    if {$res != "8547285472"} {
       return "FAIL: porttree not traversed"
    }
    return "Mport traverse successful."
} -cleanup {
    file delete -force $pwd/porttree
} -result "Mport traverse successful."


# test _mportsearchpath
# test _mportinstalled
# test _mportactive
# test _portnameactive
# test _mportispresent
# test _mporterrorifconflictsinstalled
# test _mportexec
# test mportexec
# test _upgrade_mport_deps
# test _get_registry_archs
# test getsourcepath
# test _source_is_snapshot
# test getportbuildpath
# test getportlogpath
# test getportworkpath_from_buildpath
# test getportworkpath_from_portdir
# test getindex
# test mportsync
# test mportsearch
# test mportlookup
# test mportlistall
# test _mports_load_quickindex
# test mports_generate_quickindex


# test _mportkey
# test mportdepends
# test _mport_supports_archs
# test _mport_archs
# test _active_supports_archs
# test _active_archs
# test _explain_arch_mismatch
# test _mport_has_deptypes
# test _target_needs_deps
# test _deptypes_for_target
# test selfupdate
# test upgrade
# test _upgrade
# test _upgrade_dependencies


test mportselect {
    Mport select unit test.
} -setup {
    set macports::prefix $pwd/prefix

    file mkdir $macports::prefix/etc/select/group
    set f1 [open $macports::prefix/etc/select/group/file1 w+]
    set f2 [open $macports::prefix/etc/select/group/file2 w+]
    set f3 [open $macports::prefix/srcs w+]
    puts $f1 "srcs\n"
    close $f1
    close $f2
    close $f3

    set fd [open $macports::prefix/etc/select/group/base w+]
    puts $fd "a\nb"
    close $fd
} -body {
    if {[mportselect list group] != {file1 file2}} {
       return "FAIL: files not listed"
    }
    if {[mportselect set group file1] != ""} {
       reutrn "FAIL: cannot set links"
    }
    if {![file exists $macports::prefix/a]} {
       return "FAIL: link not created"
    }
    if {[mportselect show group] != "file1"} {
       return "FAIL: file not selected"
    }
    return "Mport select successful."

} -cleanup {
    file delete -force $macports::prefix
} -result "Mport select successful."


test gettmpdir {
    Get tmp dir unit test.
} -body {
    global env
    set env(TMPDIR) temporal
    if {[macports::gettmpdir] != "temporal"} {
       return "FAIL: set temp dir not detected"
    }
    unset env(TMPDIR)
    if {[macports::gettmpdir] != "/tmp"} {
       return "FAIL: default value not set"
    }
    return "Get tmp dir successful."
} -result "Get tmp dir successful."


test arch_runnable {
    Arch runnable unit test.
} -body {
    set macports::os_major 12
    set macports::os_arch i386
    set macports::os_platform darwin
    if {[macports::arch_runnable ppc1] != no} {
       return "FAIL: major:12 arch:i386 arch:ppc* not detected"
    }
    if {[macports::arch_runnable ppc64] != no} {
       return "FAIL: major:12 arch:i386 arch:ppc64 not detected"
    }
    set macports::os_major 7
    set macports::os_arch i386
    set macports::os_platform darwin
    if {[macports::arch_runnable x86_64] != no} {
       return "FAIL: major:7 arch:i386 arch:x86_64 not detected"
    }
    set macports::os_major 12
    set macports::os_arch i386
    set macports::os_platform darwin
    if {[macports::arch_runnable x86_64] != yes} {
       return "FAIL: major:12 arch:i386 arch:x86_64 not detected"
    }
    return "Arch runnable successful."
} -result "Arch runnable successful."


# test revupgrade
# test revupgrade_scanandrebuild


test path_is_in_prefix {
    Path is in prefix unit test.
} -body {
    set macports::applications_dir appdir
    if {[macports::path_is_in_prefix appdir/test/port] != yes} {
       return "FAIL: application dir not detected"
    }
    set macports::prefix prefix
    if {[macports::path_is_in_prefix prefix/test/port] != yes} {
       return "FAIL: prefix not detected"
    }
    if {[macports::path_is_in_prefix test/port] != no} {
       return "FAIL: no prefix detected"
    }
    return "Path prefix successful."
} -result "Path prefix successful."


test revupgrade_handle_special_paths {
    Revupgrade handle special paths unit test.
} -body {
    set res [macports::revupgrade_handle_special_paths fname test_path]
    if {$res != "test_path"} {
       return "FAIL: wrong path"
    }
    set res [macports::revupgrade_handle_special_paths fname @loader_path/test_load]
    if {$res != "./test_load"} {
       return "FAIL: wrong load path"
    }
    return "Revupgrade handle special path successful."
} -result "Revupgrade handle special path successful."


# test revupgrade_buildgraph


test get_pingtime {
    Get ping time unit test.
} -setup {
    set time [expr [clock seconds] - 86300]
    set macports::ping_cache(macports.org) [list MacPorts $time]
    set macports::host_blacklisted(macports_blacklist) [list black $time]
    set macports::host_preferred(macports_pref) [list pref $time]

} -body {
    if {[macports::get_pingtime macports.org] != "MacPorts"} {
       return "FAIL: wrong ping time"
    }
    if {[macports::get_pingtime macports_blacklist] != -1} {
       return "FAIL: wrong time for blacklisted host"
    }
    if {[macports::get_pingtime macports_pref] != 1} {
       return "FAIL: wrong time for preferred host"
    }
    return "Get ping time successful."
} -result "Get ping time successful."


test set_pingtime {
    Set ping time unit test.
} -body {
    set macports::ping_cache(macports) {}
    if {[lindex [macports::set_pingtime macports 007] 0] != 007} {
       return "FAIL: ping time not set"
    }
    return "Set ping time successful."
} -result "Set ping time successful."


test get_archive_sites_conf_values {
    Get archive sites conf values unit test.
} -setup {
    file mkdir $pwd/archive_sites
    set fd [open $pwd/archive_sites/archive_sites.conf w+]
    puts $fd "name fondu"
    puts $fd "urls macports.org"
    puts $fd "type tgz"
    close $fd

    set macports::autoconf::macports_conf_path $pwd/archive_sites

} -body {
    set res [macports::get_archive_sites_conf_values]
    if {[lindex [split $res " "] 1] != "macports.org:nosubdir"} {
       return "FAIL: name not set"
    }
    if {[lindex [split $res " "] 3] != "tgz"} {
       return "FAIL: wrong type set"
    }

    set macports::archive_sites_conf_values {a b c}
    if {[macports::get_archive_sites_conf_values] != {a b c}} {
       return "FAIL: wrong  result for bad conf file"
    }
    return "Get archive sites conf values successful."

} -cleanup {
    file delete -force $pwd/archive_sites
} -result "Get archive sites conf values successful."


cleanupTests
